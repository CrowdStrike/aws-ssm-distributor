---
AWSTemplateFormatVersion: '2010-09-09'
Description: Association for CrowdStrike Falcon SSM Distributor
Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: General
        Parameters: [MainRegion]
      - Label:
          default: Falcon API Credentials
        Parameters:
          - SecretsManagerSecretName
          - FalconClientID
          - FalconSecret
          - FalconCloud
      - Label:
          default: Falcon Distributor Package Configuration
        Parameters:
          - DistributorPackageName
          - Action
          - LinuxPackageVersion
          - LinuxInstallerParams
          - WindowsPackageVersion
          - WindowsInstallerParams
      - Label:
          default: Systems Manager Association Configuration
        Parameters:
          - AutomationAssumeRoleName
          - ScheduleExpression
          - MaxErrors
          - MaxConcurrency
          - ComplianceSeverity
          - AutomationDocumentName
Parameters:
  MainRegion:
    Type: String
    Description: The main aws region to deploy the required global resources. This
      value is mainly used to allow this CloudFormation template to be used as a stackset
      allowing you to deploy to multiple accounts and regions at the same time. The
      region provided to MainRegion needs to be part of that deployment or the required
      roles and distributor package will not be created. The global resources consist
      of the automation assume role for systems manager, the lambda function used
      to create the ssm distributor package, and the iam role used by that lambda
      function.
    Default: us-east-1
  AutomationAssumeRoleName:
    Description: The name to be used when creating the automation assume role used
      to execute the distributor package.
    Type: String
    Default: crowdstrike-distributor-deploy-role
  Action:
    Description: Specify whether or not to install or uninstall the package.
    Type: String
    AllowedValues: [Install, Uninstall]
    Default: Install
  SecretsManagerSecretName:
    Description: Secrets Manager Secret Name that contains the Falcon ClientId, ClientSecret,
      and Cloud for the CrowdStrike APIs. Required if SecretStorageMethod is SecretsManager.
    Type: String
    Default: /CrowdStrike/Falcon/Distributor
  FalconClientID:
    Description: Your Falcon OAuth2 Client ID.
    NoEcho: 'true'
    Type: String
  FalconSecret:
    Description: Your Falcon OAuth2 API Secret.
    NoEcho: 'true'
    Type: String
  FalconCloud:
    Description: Your Falcon OAuth2 API Base URL.
    Type: String
  ComplianceSeverity:
    Description: The severity level that is assigned to the association
    Type: String
    AllowedValues: [CRITICAL, HIGH, LOW, MEDIUM, UNSPECIFIED]
    Default: UNSPECIFIED
  ScheduleExpression:
    Description: A cron expression that specifies a schedule when the association
      runs. The schedule runs in Coordinated Universal Time (UTC).
    Type: String
    Default: cron(0 0 */1 * * ? *)
  MaxErrors:
    Description: The number of errors that are allowed before the system stops sending
      requests to run the association on additional targets. You can specify either
      an absolute number of errors, for example 10, or a percentage of the target
      set, for example 10%.
    Type: String
    Default: ''
  MaxConcurrency:
    Description: The maximum number of targets allowed to run the association at the
      same time. You can specify a number, for example 10, or a percentage of the
      target set, for example 10%. The default value is 100%, which means all targets
      run the association at the same time.
    Type: String
    Default: ''
  LinuxInstallerParams:
    Type: String
    Default: ''
  WindowsInstallerParams:
    Type: String
    Default: ''
  LinuxPackageVersion:
    Type: String
    Default: ''
  WindowsPackageVersion:
    Type: String
    Default: ''
  AutomationDocumentName:
    Type: String
    Default: CrowdStrike-FalconSensorInstall
    Description: The name to use when creating the SSM automation document. The SSM
      Automation document is responsible for generating the required input parameters
      to run the custom-api distributor package.
  DistributorPackageName:
    Type: String
    Default: CrowdStrike-FalconSensor
    Description: The name to use when creating the SSM Distributor package.
Conditions:
  SetMaxErrors: !Not
    - !Equals [!Ref MaxErrors, '']
  SetMaxConcurrency: !Not
    - !Equals [!Ref MaxConcurrency, '']
  IsMainRegion: !Equals [!Ref "AWS::Region", !Ref MainRegion]
Resources:
  DistributorPackageS3Bucket:
    Condition: IsMainRegion
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub crowdstrike-custom-api-distributor-package-bucket-${AWS::AccountId}
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: aws:kms
              KMSMasterKeyID: alias/aws/s3
      PublicAccessBlockConfiguration:
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
  DistributorPackageS3BucketPolicy:
    Condition: IsMainRegion
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref DistributorPackageS3Bucket
      PolicyDocument:
        Id: RequireEncryptionInTransit
        Version: '2012-10-17'
        Statement:
          - Principal: '*'
            Action: '*'
            Effect: Deny
            Resource:
              - !GetAtt DistributorPackageS3Bucket.Arn
              - !Sub '${DistributorPackageS3Bucket.Arn}/*'
            Condition:
              Bool:
                aws:SecureTransport: 'false'
  LambdaExecutionRole:
    Condition: IsMainRegion
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: [lambda.amazonaws.com]
            Action: [sts:AssumeRole]
      Path: /
      Policies:
        - PolicyName: AllowLogs
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action: [logs:*]
                Resource: '*'
  DistributorPackageCreateLambda:
    Condition: IsMainRegion
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.handler
      Runtime: python3.13
      Timeout: 900
      FunctionName: !Sub ${DistributorPackageName}-create-lambda
      Description: !Sub The lambda backed customer resource provider for cloudformation.
        It manages the ${DistributorPackageName} ssm distributor package.
      Role: !GetAtt LambdaExecutionRole.Arn
      Code:
        ZipFile: |
          import hashlib
          import json
          import logging
          import os
          import time
          import zipfile
          from os.path import basename
          import boto3
          import botocore
          import cfnresponse
          from botocore.config import Config
          logging.basicConfig(level=logging.INFO)
          logger = logging.getLogger()
          config = Config(retries={"max_attempts": 10, "mode": "standard"})
          def handler(event, context):
              enabled_regions = []
              missing_regions = []
              package_name = event["ResourceProperties"].get(
                  "DistributorPackageName", "CrowdStrike-FalconSensor"
              )
              package_verison = event["ResourceProperties"].get(
                  "DistributorPackageVersion", "v1.0.0"
              )
              s3_bucket_name = event["ResourceProperties"].get("S3BucketName")
              if s3_bucket_name is None:
                  fail_response(event, context, "S3BucketName is required.")
              try:
                  account_client = boto3.client("account", config=config)
                  region_paginator = account_client.get_paginator("list_regions")
                  region_iterator = region_paginator.paginate(
                      RegionOptStatusContains=["ENABLED", "ENABLED_BY_DEFAULT"]
                  )
                  for page in region_iterator:
                      for region in page["Regions"]:
                          enabled_regions.append(region["RegionName"])
                  if event["RequestType"] in ["Create", "Update"]:
                      for region in enabled_regions:
                          ssm_client = boto3.client("ssm", region_name=region, config=config)
                          try:
                              ssm_client.describe_document(Name=package_name)
                              logger.info(
                                  f"Distributor package: {package_name} already exists in {region}"
                              )
                          except ssm_client.exceptions.InvalidDocument:
                              logger.info(
                                  f"Distributor package: {package_name} is missing in {region}"
                              )
                              missing_regions.append(region)
                          except botocore.exceptions.ClientError as error:
                              raise error
                      if len(missing_regions) > 0:
                          s3_path = f"{package_name}/{package_verison}"
                          s3_dir, manifest = create_local_packages(version=package_verison)
                          sync_s3(s3_dir, s3_bucket_name, s3_path)
                          for region in missing_regions:
                              logger.info(
                                  f"Creating distribtor package: {package_name} {package_verison} in {region}"
                              )
                              ssm_client = boto3.client("ssm", region_name=region, config=config)
                              create_distributor_package(
                                  client=ssm_client,
                                  package_name=package_name,
                                  manifest=manifest,
                                  version=package_verison,
                                  bucket=s3_bucket_name,
                                  s3_path=s3_path,
                              )
                      while len(missing_regions) > 0:
                          for region in missing_regions:
                              ssm_client = boto3.client("ssm", region_name=region, config=config)
                              try:
                                  document = ssm_client.describe_document(Name=package_name)[
                                      "Document"
                                  ]
                                  status = document["Status"]
                                  if status == "Active":
                                      logger.info(
                                          f"Distributor package: {package_name} {package_verison} successfully created in {region}."
                                      )
                                      missing_regions.remove(region)
                                      continue
                                  elif status == "Failed":
                                      status_information = document["StatusInformation"]
                                      fail_response(
                                          event,
                                          context,
                                          f"Distributor package: {package_name} {package_verison} failed during creation in {region}. Reason: {status_information}",
                                      )
                                  else:
                                      logger.info(
                                          f"Distributor package: {package_name} {package_verison} is still being created in {region}."
                                      )
                              except ssm_client.exceptions.InvalidDocument:
                                  continue
                              except botocore.exceptions.ClientError as error:
                                  raise error
                          time.sleep(5)
                      if len(missing_regions) == 0:
                          msg = f"Successfully created {package_name} {package_verison} in all regions."
                          logger.info(msg)
                          cfnresponse.send(event, context, cfnresponse.SUCCESS, {"msg": msg})
                      else:
                          fail_response(
                              event,
                              context,
                              f"The following regions are still missing the distributor package: {"".join(missing_regions)}",
                          )
                  if event["RequestType"] == "Delete":
                      target_regions = enabled_regions
                      while len(target_regions) > 0:
                          for region in target_regions:
                              ssm_client = boto3.client("ssm", region_name=region, config=config)
                              try:
                                  document = ssm_client.describe_document(Name=package_name)[
                                      "Document"
                                  ]
                                  status = document["Status"]
                                  if status != "Deleting":
                                      logger.info(
                                          f"Marking distributor package: {package_name} in {region} for deletion."
                                      )
                                      ssm_client.delete_document(Name=package_name)
                              except ssm_client.exceptions.InvalidDocument:
                                  logger.info(
                                      f"Distributor package: {package_name} in {region} was deleted."
                                  )
                                  target_regions.remove(region)
                              except botocore.exceptions.ClientError as error:
                                  raise error
                      msg = (
                          f"Successfully deleted {package_name} {package_verison} in all regions."
                      )
                      logger.info(msg)
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {"msg": msg})
              except Exception as e:
                  fail_response(event, context, e)
          def fail_response(event, context, e):
              responseData = {"error": str(e)}
              logging.error(e)
              cfnresponse.send(event, context, cfnresponse.FAILED, responseData)
              print(responseData)
          def sync_s3(s3_dir, s3_bucket_name, s3_path):
              s3_client = boto3.client("s3")
              for root, _, files in os.walk(s3_dir):
                  for file in files:
                      file_name = os.path.join(root, file)
                      logging.info(f"Uploading {file} to {s3_bucket_name}/{s3_path}/{file}.")
                      s3_client.upload_file(
                          file_name, s3_bucket_name, os.path.join(s3_path, file)
                      )
          def create_distributor_package(
              client, package_name, manifest, version, bucket, s3_path
          ):
              client.create_document(
                  Name=package_name,
                  VersionName=version,
                  DocumentType="Package",
                  Content=json.dumps(manifest),
                  DocumentFormat="JSON",
                  Attachments=[
                      {
                          "Key": "SourceUrl",
                          "Values": [f"s3://{bucket}/{s3_path}"],
                      }
                  ],
              )
          def create_local_packages(version):
              build_dir = "/tmp/builds"
              s3_dir = "/tmp/builds/s3"
              manifest_data = {
                  "schemaVersion": "2.0",
                  "publisher": "Crowdstrike Inc.",
                  "description": "The CrowdStrike Falcon cloud platform helps successfully stop breaches, all via a single lightweight agent. Learn how to protect your AWS environment with CrowdStrike at https://github.com/CrowdStrike/aws-ssm-distributor/tree/main/custom-api-package",
                  "version": version,
                  "packages": {},
                  "files": {},
              }
              for platform in DISTROS:
                  if platform == "linux":
                      install_script = linux_install_script
                      uninstall_script = linux_uninstall_script
                      file_ext = ".sh"
                  else:
                      install_script = windows_install_script
                      uninstall_script = windows_uninstall_script
                      file_ext = ".ps1"
                  for distro in DISTROS[platform]:
                      name = distro["name"]
                      version = distro["version"]
                      arch = distro["arch"]
                      logger.info("Creating package for {} {} {}".format(name, version, arch))
                      distro_dir = "{}{}-{}".format(
                          name, version.replace(".*", "").replace("_any", ""), arch
                      )
                      package_dir = f"{build_dir}/{distro_dir}"
                      write_package_script(
                          install_script,
                          f"{package_dir}/install{file_ext}",
                          distro["filter"],
                          distro["package_manager"],
                      )
                      write_package_script(
                          uninstall_script,
                          f"{package_dir}/uninstall{file_ext}",
                          distro["filter"],
                          distro["package_manager"],
                      )
                      zip_file_path = zip_package(
                          package_dir=package_dir, zip_name=distro_dir, build_dir=build_dir
                      )
                      zip_file_name = os.path.basename(zip_file_path)
                      if not name in manifest_data["packages"]:
                          manifest_data["packages"][name] = {}
                      if not version in manifest_data["packages"][name]:
                          manifest_data["packages"][name][version] = {}
                      if not arch in manifest_data["packages"][name][version]:
                          manifest_data["packages"][name][version][arch] = {}
                      manifest_data["packages"][name][version][arch] = {"file": zip_file_name}
                      manifest_data["files"][zip_file_name] = {
                          "checksums": {"sha256": get_digest(zip_file_path)}
                      }
              logger.info("Creating manifest.json")
              with open(os.path.join(s3_dir, "manifest.json"), "w") as file:
                  json.dump(manifest_data, file, indent=4)
              return s3_dir, manifest_data
          def get_digest(file):
              h = hashlib.sha256()
              with open(file, "rb") as file:
                  while True:
                      chunk = file.read(h.block_size)
                      if not chunk:
                          break
                      h.update(chunk)
                  return h.hexdigest()
          def write_package_script(script, dest, filter, package_manager):
              directory = os.path.dirname(dest)
              if directory:
                  os.makedirs(directory, exist_ok=True)
              script = script.replace(FILTER_KEYWORD, filter).replace(
                  PACKAGE_MANAGER_KEYWORD, package_manager
              )
              logger.info(f"Creating file {dest}.")
              with open(dest, "wt") as fout:
                  fout.write(script)
          def zip_package(package_dir, zip_name, build_dir):
              zip_package_name = f"{build_dir}/s3/{zip_name}.zip"
              logger.info(f"Creating zip file: {zip_package_name}")
              directory = os.path.dirname(zip_package_name)
              if directory:
                  os.makedirs(directory, exist_ok=True)
              with zipfile.ZipFile(zip_package_name, "w", zipfile.ZIP_DEFLATED) as zipf:
                  for root, _, files in os.walk(package_dir):
                      for file in files:
                          file_path = os.path.join(root, file)
                          zipf.write(file_path, basename(file_path))
              return zip_package_name
          FILTER_KEYWORD = "<<SENSOR_DOWNLOAD_FILTER>>"
          PACKAGE_MANAGER_KEYWORD = "<<PACKAGE_MANAGER>>"
          DISTROS = {
              "linux": [
                  {
                      "name": "amazon",
                      "version": "2",
                      "arch": "x86_64",
                      "package_manager": "yum",
                      "filter": "os:'Amazon Linux'+os_version:'2'+platform:'linux'",
                  },
                  {
                      "name": "amazon",
                      "version": "2",
                      "arch": "arm64",
                      "package_manager": "yum",
                      "filter": "os:'Amazon Linux'+os_version:'2 - arm64'+platform:'linux'",
                  },
                  {
                      "name": "amazon",
                      "version": "2023",
                      "arch": "x86_64",
                      "package_manager": "yum",
                      "filter": "os:'Amazon Linux'+os_version:'2023'+platform:'linux'",
                  },
                  {
                      "name": "amazon",
                      "version": "2023",
                      "arch": "arm64",
                      "package_manager": "yum",
                      "filter": "os:'Amazon Linux'+os_version:'2023 - arm64'+platform:'linux'",
                  },
                  {
                      "name": "redhat",
                      "version": "7.*",
                      "arch": "x86_64",
                      "package_manager": "yum",
                      "filter": "os:'*RHEL*'+os_version:'7'+platform:'linux'",
                  },
                  {
                      "name": "redhat",
                      "version": "8.*",
                      "arch": "x86_64",
                      "package_manager": "yum",
                      "filter": "os:'*RHEL*'+os_version:'8'+platform:'linux'",
                  },
                  {
                      "name": "redhat",
                      "version": "8.*",
                      "arch": "arm64",
                      "package_manager": "yum",
                      "filter": "os:'*RHEL*'+os_version:'8 - arm64'+platform:'linux'",
                  },
                  {
                      "name": "redhat",
                      "version": "9.*",
                      "arch": "x86_64",
                      "package_manager": "yum",
                      "filter": "os:'*RHEL*'+os_version:'9'+platform:'linux'",
                  },
                  {
                      "name": "redhat",
                      "version": "9.*",
                      "arch": "arm64",
                      "package_manager": "yum",
                      "filter": "os:'*RHEL*'+os_version:'9 - arm64'+platform:'linux'",
                  },
                  {
                      "name": "almalinux",
                      "version": "8.*",
                      "arch": "x86_64",
                      "package_manager": "yum",
                      "filter": "os:'*RHEL*'+os_version:'8'+platform:'linux'",
                  },
                  {
                      "name": "almalinux",
                      "version": "8.*",
                      "arch": "arm64",
                      "package_manager": "yum",
                      "filter": "os:'*RHEL*'+os_version:'8 - arm64'+platform:'linux'",
                  },
                  {
                      "name": "almalinux",
                      "version": "9.*",
                      "arch": "arm64",
                      "package_manager": "yum",
                      "filter": "os:'*RHEL*'+os_version:'9 - arm64'+platform:'linux'",
                  },
                  {
                      "name": "almalinux",
                      "version": "9.*",
                      "arch": "x86_64",
                      "package_manager": "yum",
                      "filter": "os:'*RHEL*'+os_version:'9'+platform:'linux'",
                  },
                  {
                      "name": "rocky",
                      "version": "8.*",
                      "arch": "x86_64",
                      "package_manager": "yum",
                      "filter": "os:'*RHEL*'+os_version:'8'+platform:'linux'",
                  },
                  {
                      "name": "rocky",
                      "version": "8.*",
                      "arch": "arm64",
                      "package_manager": "yum",
                      "filter": "os:'*RHEL*'+os_version:'8 - arm64'+platform:'linux'",
                  },
                  {
                      "name": "rocky",
                      "version": "9.*",
                      "arch": "arm64",
                      "package_manager": "yum",
                      "filter": "os:'*RHEL*'+os_version:'9 - arm64'+platform:'linux'",
                  },
                  {
                      "name": "rocky",
                      "version": "9.*",
                      "arch": "x86_64",
                      "package_manager": "yum",
                      "filter": "os:'*RHEL*'+os_version:'9'+platform:'linux'",
                  },
                  {
                      "name": "centos",
                      "version": "7.*",
                      "arch": "x86_64",
                      "package_manager": "yum",
                      "filter": "os:'*CentOS*'+os_version:'7'+platform:'linux'",
                  },
                  {
                      "name": "centos",
                      "version": "8.*",
                      "arch": "x86_64",
                      "package_manager": "yum",
                      "filter": "os:'*CentOS*'+os_version:'8'+platform:'linux'",
                  },
                  {
                      "name": "centos",
                      "version": "8.*",
                      "arch": "arm64",
                      "package_manager": "yum",
                      "filter": "os:'*CentOS*'+os_version:'8 - arm64'+platform:'linux'",
                  },
                  {
                      "name": "oracle",
                      "version": "6.*",
                      "arch": "x86_64",
                      "package_manager": "yum",
                      "filter": "os:'*Oracle*'+os_version:'6'+platform:'linux'",
                  },
                  {
                      "name": "oracle",
                      "version": "7.*",
                      "arch": "x86_64",
                      "package_manager": "yum",
                      "filter": "os:'*Oracle*'+os_version:'7'+platform:'linux'",
                  },
                  {
                      "name": "oracle",
                      "version": "8.*",
                      "arch": "x86_64",
                      "package_manager": "yum",
                      "filter": "os:'*Oracle*'+os_version:'8'+platform:'linux'",
                  },
                  {
                      "name": "suse",
                      "version": "12.*",
                      "arch": "x86_64",
                      "package_manager": "zypper",
                      "filter": "os:'*SLES*'+os_version:'12'+os_version:!~'zLinux'+platform:'linux'",
                  },
                  {
                      "name": "suse",
                      "version": "15.*",
                      "arch": "x86_64",
                      "package_manager": "zypper",
                      "filter": "os:'*SLES*'+os_version:'15'+os_version:!~'zLinux'+platform:'linux'",
                  },
                  {
                      "name": "ubuntu",
                      "version": "16.*",
                      "arch": "x86_64",
                      "package_manager": "dpkg",
                      "filter": "os:'*Ubuntu*'+os_version:'*16*'+os_version:!'*arm64*'+os_version:!~'zLinux'+platform:'linux'",
                  },
                  {
                      "name": "ubuntu",
                      "version": "18.*",
                      "arch": "x86_64",
                      "package_manager": "dpkg",
                      "filter": "os:'*Ubuntu*'+os_version:'*18*'+os_version:!'*arm64*'+os_version:!~'zLinux'+platform:'linux'",
                  },
                  {
                      "name": "ubuntu",
                      "version": "20.*",
                      "arch": "x86_64",
                      "package_manager": "dpkg",
                      "filter": "os:'*Ubuntu*'+os_version:'*20*'+os_version:!'*arm64*'+os_version:!~'zLinux'+platform:'linux'",
                  },
                  {
                      "name": "ubuntu",
                      "version": "22.*",
                      "minor_version": "*",
                      "arch": "x86_64",
                      "package_manager": "dpkg",
                      "filter": "os:'*Ubuntu*'+os_version:'*22*'+os_version:!'*arm64*'+os_version:!~'zLinux'+platform:'linux'",
                  },
                  {
                      "name": "ubuntu",
                      "version": "24.*",
                      "minor_version": "*",
                      "arch": "x86_64",
                      "package_manager": "dpkg",
                      "filter": "os:'*Ubuntu*'+os_version:'*24*'+os_version:!'*arm64*'+os_version:!~'zLinux'+platform:'linux'",
                  },
                  {
                      "name": "ubuntu",
                      "version": "24.*",
                      "arch": "arm64",
                      "package_manager": "dpkg",
                      "filter": "os:'*Ubuntu*'+os_version:'*24*'+os_version:~'arm64'+platform:'linux'",
                  },
                  {
                      "id": "ubuntu22",
                      "name": "ubuntu",
                      "version": "22.*",
                      "arch": "arm64",
                      "package_manager": "dpkg",
                      "filter": "os:'*Ubuntu*'+os_version:'*22*'+os_version:~'arm64'+platform:'linux'",
                  },
                  {
                      "name": "ubuntu",
                      "version": "18.*",
                      "arch": "arm64",
                      "package_manager": "dpkg",
                      "filter": "os:'*Ubuntu*'+os_version:'*18*'+os_version:~'arm64'+platform:'linux'",
                  },
                  {
                      "name": "ubuntu",
                      "version": "20.*",
                      "arch": "arm64",
                      "package_manager": "dpkg",
                      "filter": "os:'*Ubuntu*'+os_version:'*20*'+os_version:~'arm64'+platform:'linux'",
                  },
                  {
                      "name": "debian",
                      "version": "9.*",
                      "arch": "x86_64",
                      "package_manager": "dpkg",
                      "filter": "os:'Debian'+os_version:'*9*'+os_version:!'*arm64*'+os_version:!~'zLinux'+platform:'linux'",
                  },
                  {
                      "name": "debian",
                      "version": "10.*",
                      "minor_version": "*",
                      "arch": "x86_64",
                      "package_manager": "dpkg",
                      "filter": "os:'Debian'+os_version:'*10*'+os_version:!'*arm64*'+os_version:!~'zLinux'+platform:'linux'",
                  },
                  {
                      "name": "debian",
                      "version": "11.*",
                      "arch": "x86_64",
                      "package_manager": "dpkg",
                      "filter": "os:'Debian'+os_version:'*11*'+os_version:!'*arm64*'+os_version:!~'zLinux'+platform:'linux'",
                  },
                  {
                      "name": "debian",
                      "version": "12.*",
                      "arch": "x86_64",
                      "package_manager": "dpkg",
                      "filter": "os:'Debian'+os_version:'*12*'+os_version:!'*arm64*'+os_version:!~'zLinux'+platform:'linux'",
                  },
                  {
                      "name": "debian",
                      "version": "12",
                      "minor_version": "*",
                      "arch": "arm64",
                      "package_manager": "dpkg",
                      "filter": "os:'Debian'+os_version:'*12*'+os_version:~'arm64'+platform:'linux'",
                  },
              ],
              "windows": [
                  {
                      "name": "windows",
                      "version": "_any",
                      "arch": "_any",
                      "package_manager": "",
                      "filter": "os:'Windows'+platform:'windows'",
                  }
              ],
          }
          linux_install_script = r"""#!/bin/bash
          if pgrep  -u root falcon-sensor >/dev/null 2>&1 ; then
            echo "Falcon Sensor already installed... if you want to update or downgrade, please use Sensor Update Policies in the CrowdStrike console. Please see: https://falcon.crowdstrike.com/documentation/66/sensor-update-policies for more information."
            exit 0
          fi

          # Error Handling
          function errout {
              rc="$?"
              echo "[ERROR] Falcon Sensor installation failed with $rc while executing '$2' on line $1"
              exit "$rc"
          }
          trap 'errout "${LINENO}" "${BASH_COMMAND}" ' ERR

          # Echo to stderr
          function errcho {
              >&2 echo ${@}
              exit 1
          }

          # For logging the commands we run.  NOTE: remember not to log URLs or tokens!
          function RUN {
              echo "info: Running [$*]"
              "$@"
          }
          function EncodeQueryParameter {
            QueryParameter="$1"
            QueryParameter="${QueryParameter//+/%2b}"
            QueryParameter="${QueryParameter//\'/%27}"
            QueryParameter="${QueryParameter//:/%3a}"
            QueryParameter="${QueryParameter// /%20}"
            echo "$QueryParameter"
          }

          # Starting
          echo 'Installing Falcon Sensor...'

          # Parameters
          INSTALLER_LOC="/tmp"

          # Get config params
          echo 'Getting required config params ...'
          if [[ -z "$SSM_CS_CCID" ]]; then
              errcho "Missing required param SSM_CS_CCID. If the required parameter was passed to the package, ensure the target instance has a ssm agent version of 2.3.1550.0 or greater installed."
              exit 1
          fi
          proxy=""
          proxy_name=""
          proxy_port=""
          CCID="${SSM_CS_CCID}"
          INSTALLTOKEN="${SSM_CS_INSTALLTOKEN}"
          SSM_CS_LINUX_INSTALLPARAMS="${SSM_CS_LINUX_INSTALLPARAMS:-}"
          SSM_CS_LINUX_INSTALLPARAMS="${SSM_CS_LINUX_INSTALLPARAMS//\\\`/\\\``}"
          SSM_CS_LINUX_INSTALLPARAMS="${SSM_CS_LINUX_INSTALLPARAMS//\\\$/\\\$}"
          declare -a INSTALLPARAMS="($SSM_CS_LINUX_INSTALLPARAMS)"
          for arg in "${INSTALLPARAMS[@]}"; do
              if [[ $arg == *"--aph="* ]]; then
                  proxy_name="${arg#*=}"
                  # Remove https/http
                  proxy_name="${proxy_name//http*:'//'}"
                  echo "Proxy host $proxy_name found in arguments"
              elif [[ $arg == *"--app="* ]]; then       
                  proxy_port="${arg#*=}"
                  echo "Proxy port $proxy_port found in arguments"
              fi
          done
          if [ -n "$proxy_name" ] && [ -n "$proxy_port" ]; then
              proxy="http://$proxy_name:$proxy_port"
          elif [ -n "$proxy_name" ]; then
              proxy="http://$proxy_name"
          fi
          if [ -n "$proxy" ]; then
              proxy="${proxy//\"}"
              proxy="${proxy//\'}"
              echo "Proxy settings detected in arguments, using proxy: $proxy to communicate with the CrowdStrike Apis"
          fi
          userAgent="crowdstrike-custom-api-distributor-package/v2.0.0"
          BASE_FILTER="<<SENSOR_DOWNLOAD_FILTER>>"
          BASE_URL="https://${SSM_CS_HOST}/sensors/combined/installers/v1?limit=1&sort=version"
          if [[ -n $SSM_CS_LINUX_VERSION ]]; then
              FILTER="${BASE_FILTER}+version:'${SSM_CS_LINUX_VERSION}'"
              URL="$BASE_URL&filter=$(EncodeQueryParameter "$FILTER")"
              echo "Version specified, grabbing the exact version: ${SSM_CS_LINUX_VERSION}. Filter: ${FILTER}"
          else
              FILTER="${BASE_FILTER}"
              URL="$BASE_URL&offset=1&filter=$(EncodeQueryParameter "$FILTER")"
              echo "No version specified, grabbing the n-1 version that matches the base filter. Filter: ${FILTER}"
          fi

          # Getting installer
          echo 'Getting installer sha256...'
          if ! _resp="$(curl -x "$proxy" --retry 15 --retry-delay 10 -sf -H "Authorization: Bearer ${SSM_CS_AUTH_TOKEN}" -H "User-Agent: $userAgent" "$URL")" ; then
              errcho "Failed grabbing presigned url: $URL (exit status $?)..."
          fi
          if ! grep -q -e "name" -e "sha256" <<<"${_resp}"; then
              errcho "No sha256 or package name returned from api call: $_resp..."
          fi
          _fname="$(echo -n "${_resp}" | grep "name" | cut -d\" -f4)"
          _sha256="$(echo -n "${_resp}" | grep "sha256" | cut -d\" -f4)"
          _version="$(echo -n "${_resp}" | grep '"version"' | cut -d\" -f4)"
          _binary_path="${INSTALLER_LOC}/${_fname}"
          _download_url="https://$SSM_CS_HOST/sensors/entities/download-installer/v1?id=$_sha256"
          echo "Downloading sensor binary matching sha256 $_sha256..."
          if ! _resp="$(curl -x "$proxy" --retry 15 --retry-delay 10 -sf -H "Authorization: Bearer ${SSM_CS_AUTH_TOKEN}" -H "User-Agent: $userAgent" "$_download_url" -o "${_binary_path}")" ; then
              errcho "Failed downloading binary: $_download_url (exit status $?)..."
          fi
          sensor_install_dpkg()
          {
              INSTALLER="$(realpath "$1")"
              RUN export DEBIAN_FRONTEND=noninteractive
              RUN apt-get update
              RUN apt-get -y install "$INSTALLER"
          }
          sensor_install_yum()
          {
              INSTALLER="${1}"
              sudo rpm -qa | grep falcon-sensor || yum install "${INSTALLER}" -y
          }
          sensor_install_zypper()
          {
              INSTALLER="${1}"
              sudo zypper -n --no-gpg-checks install "${INSTALLER}"
          }
          echo "Running install command (installing ${_binary_path}) sensor version: ${_version}..."
          case "<<PACKAGE_MANAGER>>" in
            "dpkg")
              sensor_install_dpkg "${_binary_path}"
              ;;
            "yum")
              sensor_install_yum "${_binary_path}"
              ;;
            "zypper")
              sensor_install_zypper "${_binary_path}"
              ;;
            *)
              errcho "Unknown package manager."
              exit 1
              ;;
          esac
          if [[ "$INSTALLTOKEN" ]]; then
                echo "Passing installation token..."
                INSTALLPARAMS+=("--provisioning-token=$INSTALLTOKEN")
          fi
          INSTALLPARAMS+=("--cid=$CCID")

          # Configure Falcon sensor
          RUN /opt/CrowdStrike/falconctl -s "${INSTALLPARAMS[@]}"

          # Start Falcon sensor
          if [[ -L "/sbin/init" ]]
          then
              RUN systemctl start falcon-sensor
          else
              RUN sudo service falcon-sensor start
          fi

          # Sleep before verification
          sleep 5s

          # Verification
          if ps -e | grep falcon-sensor &>/dev/null ;
          then
              unset SSM_CS_INSTALLTOKEN
              unset SSM_CS_LINUX_INSTALLPARAMS
              unset SSM_CS_CCID
              unset SSM_CS_AUTH_TOKEN
              unset SSM_CS_HOST
              rm "${_binary_path}" || true
              echo "Falcon Sensor version ${_version} installed successfully."
          else
              errcho "Installation failed. Process falcon-sensor is not running."
              exit 1
          fi
          """
          linux_uninstall_script = r"""#!/bin/bash
          echo 'Uninstalling Falcon Sensor...'

          # Error Handling
          function errout {
              rc="$?"
              echo "[ERROR] Falcon Sensor un-installation failed with $rc while executing '$2' on line $1"
              exit "$rc"
          }
          trap 'errout "${LINENO}" "${BASH_COMMAND}" ' ERR

          # Echo to stderr
          function errcho {
              >&2 echo ${@}
          }

          # Starting
          aid="$(sudo /opt/CrowdStrike/falconctl -g --aid | awk -F\" '{print $2}')"
          pkg="falcon-sensor"
          echo "Running uninstall command for agent $aid ... "
          if type dnf >/dev/null 2>&1; then
              sudo dnf remove -q -y "$pkg" || sudo rpm -e --nodeps "$pkg"
          elif type yum >/dev/null 2>&1; then
              sudo yum remove -q -y "$pkg" || sudo rpm -e --nodeps "$pkg"
          elif type zypper >/dev/null 2>&1; then
              sudo zypper --n remove -y "$pkg" || sudo rpm -e --nodeps "$pkg"
          elif type apt >/dev/null 2>&1; then
              DEBIAN_FRONTEND=noninteractive sudo apt-get purge -y "$pkg"
          else
            sudo rpm -e --nodeps "$pkg"
          fi

          # Verification
          if ! pgrep falcon-sensor >/dev/null; then
              echo "Successfully finished uninstall..."
          else
              errcho "Uninstall failed. Process falcon-sensor is still running."
              exit 1
          fi
          """
          windows_install_script = r"""[CmdletBinding()]
          param()

          #########
          # Setup  #
          #########
          Write-Output 'Installing Falcon Sensor...'
              
          $ErrorActionPreference = "Stop"
              
          function Convert-EncodeQueryParameter {
              param (
                  [Parameter(Mandatory = $true)]
                  [string]$QueryParameter
              )
                  
              return $QueryParameter.Replace("+", "%2b").Replace("'", "%27").Replace(":", "%3a").Replace(" ", "%20")
          }
              
          $agentService = Get-Service -Name CSAgent -ErrorAction SilentlyContinue
              
          if ($agentService) {
              Write-Output 'Falcon Sensor already installed... if you want to update or downgrade, please use Sensor Update Policies in the CrowdStrike console. Please see: https://falcon.crowdstrike.com/documentation/66/sensor-update-policies for more information.'
              Exit 0
          }
          if (-not $env:SSM_CS_CCID) {
              throw "Missing required parameter $($env:SSM_CS_CCID). If the required parameter was passed to the package, ensure the target instance has a ssm agent version of 2.3.1550.0 or greater installed."
          }
          $baseFilter = "os:'Windows'+platform:'windows'"
          if ($env:SSM_CS_WINDOWS_VERSION) {
              $sensorFilter = Convert-EncodeQueryParameter -QueryParameter ($baseFilter + "+version:'${env:SSM_CS_WINDOWS_VERSION}'")
              $queryString = "limit=1&filter=${sensorFilter}"
              Write-Output "Version specified, grabbing the exact version: ${env:SSM_CS_WINDOWS_VERSION}. Query string: ${queryString}"
          }
          else {
              # If no version is specified, we will grab the n-1 version that matches the base filter
              $sensorFilter = Convert-EncodeQueryParameter -QueryParameter $baseFilter
              $queryString = "limit=1&offset=1&sort=version&filter=${sensorFilter}"
              Write-Output "No version specified, grabbing the n-1 version that matches the base filter. Query string: ${queryString}"
          }
          $headers = @{
              'Authorization' = "Bearer ${env:SSM_CS_AUTH_TOKEN}"
              'User-Agent'    = 'crowdstrike-custom-api-distributor-package/v2.0.0'
          }  
          $installArguments = @(
              , '/install'
              , '/quiet'
              , '/norestart'
              , "CID=${env:SSM_CS_CCID}"
              , 'ProvWaitTime=1200000'
          )
          $Space = ' '
          if ($env:SSM_CS_WINDOWS_INSTALLPARAMS) {
              $installArguments += $env:SSM_CS_WINDOWS_INSTALLPARAMS.Split($Space)
          }    
          if ($env:SSM_CS_INSTALLTOKEN) {
              $installArguments += "ProvToken=${env:SSM_CS_INSTALLTOKEN}"
          }
          $proxy = ""
          if ($installArguments -match "app_proxyname") {
              Write-Output "Proxy settings detected in arguments, using proxy settings to communicate with the CrowdStrike api"
              foreach ($arg in $installArguments) {
                  $field = $arg.Split("=")
                  
                  if ($field[0] -eq "app_proxyname") {
                      $proxy_host = $field[1].Replace("http://", "").Replace("https://", "")
                      Write-Output "Proxy host ${proxy_host} found in arguments"
                  }    
                  if ($field[0] -eq "app_proxyport") {
                      $proxy_port = $field[1]
                      Write-Output "Proxy port ${proxy_port} found in arguments"
                  }    
              }    
              if ($proxy_port -ne "") {
                  $proxy = "http://${proxy_host}:${proxy_port}"
              }    
              else {
                  $proxy = "http://${proxy_host}"
              }    
              $proxy = $proxy.Replace("'", "").Replace("`"", "")
              Write-Output "Using proxy: ${proxy} to communicate with the CrowdStrike Apis"
          }    

          ###################
          # Sensor Download  #
          ###################
          [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
          $maxRetry = 15
          $retryCount = 0
          $retryDelaySeconds = 10
          do {
              $uri = "https://${env:SSM_CS_HOST}/sensors/combined/installers/v1?${queryString}"
              Write-Output "Grabbing the Sha256 of the falcon sensor package, Calling $uri"
              try {
                  if ($proxy -ne "") {
                      $resp = Invoke-WebRequest -Method Get -Proxy $proxy -Uri $uri -Headers $headers -UseBasicParsing -ErrorAction Stop
                  }    
                  else {
                      $resp = Invoke-WebRequest -Method Get -Uri $uri -Headers $headers -UseBasicParsing -ErrorAction Stop
                  }    
              }    
              catch {
                  $resp = $_.Exception.Response
                  if ($null -eq $resp) {
                      throw "Unexpected error: $($_.Exception.Message)"
                  }    
                  if ($resp.StatusCode -eq 429) {
                      $retryCount++
                      Write-Output "Rate limit exceeded, retrying in ${retryDelaySeconds} seconds... (retry ${retryCount} of ${maxRetry})"
                      Start-Sleep -Seconds $retryDelaySeconds
                  }    
              }    
          } while ($retryCount -lt $maxRetry -and $resp.StatusCode -eq 429)    
          if ($resp.StatusCode -eq 429) {
              throw "Rate limit exceeded, and max retries (${maxRetry}) reached."
          }    
          if ($resp.StatusCode -ne 200) {
              throw "Unexpected response code: $($resp.StatusCode) Response: $($resp.Content)"
          }    
          $content = ConvertFrom-Json -InputObject $resp.Content
          # CHECK IF $content.resources IS EMPTY
          # IF EMPTY, THROW ERROR
          if ($content.resources.Count -eq 0) {
              throw "No sensor found for filter: ${queryString} Response: $($resp.Content)"
          }
          # Check if $resp.resources HAS MORE THAN 1 ELEMENT
          # IF MORE THAN 1 ELEMENT, THROW ERROR
          if ($content.resources.Count -gt 1) {
              throw "More than one sensor found for filter: ${queryString} Response: $($resp.Content)"
          }    
          # IF NOT EMPTY, CHECK IF $resp.resources[0].signed_url IS EMPTY/NULL or $resp.resources[0].name IS EMPTY/NULL
          # IF EMPTY/NULL, THROW ERROR
          if ($null -eq $content.resources[0].sha256 -or $null -eq $content.resources[0].name) {
              throw "Resources returned, but were missing the sha256 or name field. Please report this error. Response: $($resp.Content)"
          }    
          $installerName = $content.resources[0].name
          $installerSha256 = $content.resources[0].sha256
          $version = $content.resources[0].version
          $ProgressPreference = 'SilentlyContinue'
          $maxRetry = 15
          $retryCount = 0
          $retryDelaySeconds = 10
          $installerPath = Join-Path -Path $PSScriptRoot -ChildPath $installerName
          do {
              $uri = "https://${env:SSM_CS_HOST}/sensors/entities/download-installer/v1?id=$installerSha256"
              Write-Output "Downloading the package matching Sha256: $installerSha256. Calling $uri"
              try {
                  if ($proxy -ne "") {
                      $resp = Invoke-WebRequest -Method Get -Proxy $proxy -Uri $uri -Headers $headers -UseBasicParsing -OutFile $installerPath -ErrorAction Stop
                  }    
                  else {
                      $resp = Invoke-WebRequest -Method Get -Uri $uri -Headers $headers -UseBasicParsing -OutFile $installerPath -ErrorAction Stop
                  }    
              }    
              catch {
                  $resp = $_.Exception.Response
                  if ($null -eq $resp) {
                      throw "Unexpected error: $($_.Exception.Message)"
                  }    
                  if ($resp.StatusCode -eq 429) {
                      $retryCount++
                      Write-Output "Rate limit exceeded, retrying in ${retryDelaySeconds} seconds... (retry ${retryCount} of ${maxRetry})"
                      Start-Sleep -Seconds $retryDelaySeconds
                  }    
              }    
          } while ($retryCount -lt $maxRetry -and $resp.StatusCode -eq 429)    
          if ($resp.StatusCode -eq 429) {
              throw "Rate limit exceeded, and max retries (${maxRetry}) reached."
          }    
          if (-not (Test-Path -Path $installerPath)) {
              throw "Failed to download the file. Error $(ConvertTo-Json $resp -Depth 10)"
          } 

          ###########
          # Install  #
          ###########
          Write-Host "Installer downloaded to: $installerPath"
          Write-Output "Running installer for sensor version: ${version} with arguments: $installArguments"
          $installerProcess = Start-Process -FilePath $installerPath -ArgumentList $installArguments -PassThru -Wait
          if ($installerProcess.ExitCode -ne 0) {
              throw "Installer returned exit code $($installerProcess.ExitCode)"
          }
          $agentService = Get-Service -Name CSAgent -ErrorAction SilentlyContinue
          if (-not $agentService) {
              throw 'Installer completed, but CSAgent service is missing...'
          }
          elseif ($agentService.Status -eq 'Running') {
              Write-Output 'CSAgent service running...'
          }
          else {
              throw 'Installer completed, but CSAgent service is not running...'
          }
          Write-Output "Falcon Sensor version ${version} installed successfully."
          """
          windows_uninstall_script = r"""[CmdletBinding()]
          param()
          Write-Output 'Uninstalling Falcon Sensor...'

          # Configures the TLS version to use for secure connections
          [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
          $agentService = Get-Service -Name CSAgent -ErrorAction SilentlyContinue
          if (-not $agentService) {
            Write-Output 'CSAgent service not installed...'
            Exit 0
          }

          # Retrieves the package for the CrowdStrike Windows Sensor using PowerShell's Get-Package cmdlet
          $package = Get-Package -Name 'CrowdStrike Windows Sensor'

          # Retrieves the path to the uninstall executable from the package metadata
          $uninstallString = $package.Metadata['BundleCachePath']

          # Sets up the arguments to be passed to the uninstall executable
          $uninstallArgs = '/uninstall /quiet' + $env:SSM_WIN_UNINSTALLPARAMS
          if ($env:MAINTENANCE_TOKEN) {
            $uninstallArgs += ' MAINTENANCE_TOKEN=' + $env:MAINTENANCE_TOKEN
          }

          # Starts the uninstall process and waits for it to complete
          Write-Output "Uninstalling with arguments: $uninstallArgs"
          $uninstallProcess = Start-Process -FilePath $uninstallString -ArgumentList $uninstallArgs -PassThru -Wait

          # Checks the exit code of the uninstall process and throws an exception if it is not 0
          if ($uninstallProcess.ExitCode -ne 0) {
            Write-Output "Failed to uninstall with exit code: $($uninstallProcess.ExitCode)"
            exit 1
          }

          # Retrieves the status of the CSAgent service and throws an exception if it is still running after the uninstall
          $agentService = Get-Service -Name CSAgent -ErrorAction SilentlyContinue
          if ($agentService -and $agentService.Status -eq 'Running') {
            Write-Output 'Uninstall process completed, but CSAgent service is still running. Uninstall failed for unknown reason...'
            exit 1 
          }

          # Checks if the CrowdStrike registry key was successfully removed and throws an exception if it still exists
          if (Test-Path -Path HKLM:\System\Crowdstrike) {
            Write-Output 'CrowdStrike registry key still exists. Uninstall failed.'
            exit 1
          }

          # Checks if the CrowdStrike driver was successfully removed and throws an exception if it still exists
          if (Test-Path -Path "${env:SYSTEMROOT}\System32\drivers\CrowdStrike") {
            Write-Output 'CrowdStrike driver still exists. Uninstall failed.'
            exit 1
          }
          Write-Output 'Successfully finished uninstall...'"""
          if __name__ == "__main__":
              handler(
                  {
                      "ResourceProperties": {
                          "DistributorPackageName": "CrowdStrike-FalconSensorTest",
                          "S3BucketName": "ffalor-ssm-state-manager1",
                      },
                      "RequestType": "Delete",
                  },
                  "",
              )
  DistributorPackageCreate:
    Condition: IsMainRegion
    Type: AWS::CloudFormation::CustomResource
    Properties:
      ServiceTimeout: 900
      ServiceToken: !GetAtt DistributorPackageCreateLambda.Arn
      S3BucketName: !Ref DistributorPackageS3Bucket
      DistributorPackageName: !Ref DistributorPackageName
  SSMAutomationRole:
    Condition: IsMainRegion
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Ref AutomationAssumeRoleName
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ssm.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonSSMAutomationRole
        - arn:aws:iam::aws:policy/SecretsManagerReadWrite
  CrowdStrikeSecrets:
    Type: AWS::SecretsManager::Secret
    Properties:
      Description: CrowdStrike Falcon Credentials for SSM Distributor
      Name: !Ref SecretsManagerSecretName
      SecretString:
        Fn::Join:
          - ''
          -   - '{"ClientId":"'
              - Ref: FalconClientID
              - '","ClientSecret":"'
              - Ref: FalconSecret
              - '","Cloud": "'
              - Ref: FalconCloud
              - '"}'
  CrowdStrikeAutomationDocument:
    Type: AWS::SSM::Document
    Properties:
      Name: !Ref AutomationDocumentName
      DocumentType: Automation
      Content:
        description: Automation Document for installing Crowdstike's Falcon Sensor.
        schemaVersion: '0.3'
        assumeRole: '{{ AutomationAssumeRole }}'
        parameters:
          AutomationAssumeRole:
            type: String
            description: (Required) The ARN of the role that allows Automation to
              perform the actions on your behalf. If no role is specified, Systems
              Manager Automation uses your IAM permissions to run this runbook.
            default: ''
          DistributorPackageName:
            type: String
            description: The name of the custom-api distributor package.
            default: !Ref DistributorPackageName
          Action:
            type: String
            allowedValues: [Install, Uninstall]
            description: (Required) Specify whether or not to install or uninstall
              the package.
            default: Install
          LinuxPackageVersion:
            type: String
            description: (Optional) The version of the package to install or uninstall
              on Linux nodes. If you do not specify a version, the system installs
              the default version specified by the Distributor package.
            default: ''
          LinuxInstallerParams:
            type: String
            default: ''
            description: |-
              (Optional) Enter CrowdStrike's install time params to be used on Linux nodes. For more information refer to the console.
          WindowsPackageVersion:
            type: String
            description: (Optional) The version of the package to install or uninstall
              on Windows nodes. If you do not specify a version, the system installs
              the default version specified by the Distributor package.
            default: ''
          WindowsInstallerParams:
            type: String
            default: ''
            description: |-
              (Optional) Enter CrowdStrike's install time params to be used on Windows nodes. For more information refer to the console.
          SecretStorageMethod:
            type: String
            default: ParameterStore
            description: The method used to store the Falcon ClientId, ClientSecret,
              and Cloud for the CrowdStrike APIs.
            allowedValues: [ParameterStore, SecretsManager]
          FalconCloud:
            type: String
            description: SSM Parameter Store name that contains the Falcon Cloud URL
              for CrowdStrike APIs. Required if SecretStorageMethod is ParameterStore.
            default: /CrowdStrike/Falcon/Cloud
          FalconClientId:
            type: String
            default: /CrowdStrike/Falcon/ClientId
            description: SSM Parameter Store name that contains the Falcon Client
              Id for CrowdStrike APIs. Required if SecretStorageMethod is ParameterStore.
          FalconClientSecret:
            type: String
            description: SSM Parameter Store name that contains the Falcon Client
              Secret for CrowdStrike APIs. Required if SecretStorageMethod is ParameterStore.
            default: /CrowdStrike/Falcon/ClientSecret
          SecretsManagerSecretName:
            type: String
            description: Secrets Manager Secret Name that contains the Falcon ClientId,
              ClientSecret, and Cloud for the CrowdStrike APIs. Required if SecretStorageMethod
              is SecretsManager. Refer to the user guide for required value format.
            default: /CrowdStrike/Falcon/Distributor
          InstanceIds:
            type: StringList
          Targets:
            type: MapList
            default: []
        mainSteps:
          - name: HandlePreqrequisites
            action: aws:executeScript
            nextStep: Branch
            isEnd: false
            onFailure: Abort
            inputs:
              Runtime: python3.11
              Handler: script_handler
              InputPayload:
                instances: '{{ InstanceIds }}'
                region: '{{global:REGION}}'
                falconCloud: '{{FalconCloud}}'
                falconClientId: '{{FalconClientId}}'
                falconClientSecret: '{{FalconClientSecret}}'
                secretsManagerSecretName: '{{SecretsManagerSecretName}}'
                secretStorageMethod: '{{SecretStorageMethod}}'
              Script: |-
                """Module for handling prerequisites for CrowdStrike Falcon AWS Automation document"""
                import http.client
                import urllib.parse
                import time
                from datetime import datetime
                import json
                from enum import StrEnum
                import boto3
                from botocore.config import Config
                import botocore.exceptions
                class CrowdStrikeAPIError(Exception):
                    """Crowdstrike API error"""
                class InstanceStatus(StrEnum):
                    """Enum for the InstanceStatus of the instance"""
                    ACTIVE = "Active"
                    CONNECTIONLOST = "ConnectionLost"
                    STOPPED = "Stopped"
                    TERMINATED = "Terminated"
                    UNKNOWN = "Unknown"
                class PingStatus(StrEnum):
                    """Enum for the PingStatus of the instance"""
                    ONLINE = "Online"
                    CONNECTIONLOST = "ConnectionLost"
                    INACTIVE = "Inactive"
                def pretty_print_instances(instances):
                    instancesStr = "\n[\n  "
                    instancesStr += ",\n  ".join(f'"{i}"' for i in instances)
                    instancesStr += "\n]"
                    return instancesStr
                class Falcon:
                    """Crowdstrike Falcon API class"""
                    def __init__(self, cloud, client_id, client_secret, bearer_token=None):
                        """Default constructor
                        Args:
                            cloud (str): Falcon API Gateway
                            client_id (str): Falcon OAuth2 Client ID
                            client_secret (str): Falcon OAuth2 Client Secret
                            bearer_token (str, optional): CrowdStrike API OAUTH2 Token. Defaults to None.
                        """
                        self.cloud = cloud.replace("https://", "").replace("http://", "").replace("/", "")
                        self.client_id = client_id
                        self.client_secret = client_secret
                        self.user_agent = "crowdstrike-custom-api-automation-doc/v2.0.0"
                        self.bearer_token = bearer_token
                    def _handle_redirect(self, res):
                        """Updates the cloud attribute with the new location received in the redirect
                        Args:
                            res (HTTPResponse): HTTP response object
                        Raises:
                            CrowdStrikeAPIError: If we are unable to handle the redirect
                        """
                        location = res.getheader("Location")
                        if location is None:
                            raise CrowdStrikeAPIError(
                                f"Received redirect to {res.getheader('X-Cs-Region')}, but no location header was found. Ensure you are using the correct API Gateway."
                            )
                        new_cloud = urllib.parse.urlparse(location).netloc
                        print(
                            f"WARNING: While using {self.cloud}, received redirect to {new_cloud}. Please update the value used for the crowdstrike cloud to prevent future redirects."
                        )
                        self.cloud = new_cloud
                    def _handle_rate_limit(self, res):
                        """Handles rate limit exceptions by sleeping 10 seconds or X-RateLimit-RetryAfter
                        whichever is largest
                        Args:
                            res (HTTPResponse): HTTP response object
                        """
                        retry_after = int(res.getheader("X-RateLimit-RetryAfter"))
                        retry_datetime = datetime.utcfromtimestamp(retry_after)
                        now = datetime.utcnow()
                        wait_duration = max((retry_datetime - now).total_seconds(), 10)
                        print(f"Rate limit exceeded. Retrying after {wait_duration} seconds.")
                        time.sleep(wait_duration)
                    def _oauth(self):
                        """Creates OAuth bearer token
                        Returns:
                            token (str): OAuth bearer token
                        Raises:
                            CrowdStrikeAPIError: If the API call fails
                        """
                        print("Requesting Authentication token from Crowdstrike backend.")
                        params = urllib.parse.urlencode(
                            {
                                "client_id": self.client_id,
                                "client_secret": self.client_secret,
                            }
                        )
                        headers = {
                            "Content-Type": "application/x-www-form-urlencoded",
                            "User-Agent": self.user_agent,
                        }
                        conn = http.client.HTTPSConnection(self.cloud)
                        conn.request("POST", "/oauth2/token", params, headers)
                        res = conn.getresponse()
                        if res.status == 429:
                            self._handle_rate_limit(res)
                            return self._oauth()
                        if res.status in [301, 302, 303, 307, 308]:
                            self._handle_redirect(res)
                            return self._oauth()
                        if res.status != 201:
                            raise CrowdStrikeAPIError(
                                f"Received non success response {res.status} while fetching token. Error {res.reason}"
                            )
                        data = res.read()
                        print("Successfully received OAuth token.")
                        self.bearer_token = json.loads(data)["access_token"]
                    def get_ccid(self):
                        """Returns the Customer ID
                        Returns:
                            ccid (str): Customer ID
                        Raises:
                            CrowdStrikeAPIError: If the API call fails
                        """
                        print("Requesting Customer ID from Crowdstrike backend.")
                        if self.bearer_token is None:
                            self._oauth()
                        headers = {
                            "Authorization": f"Bearer {self.bearer_token}",
                            "User-Agent": self.user_agent,
                        }
                        conn = http.client.HTTPSConnection(self.cloud)
                        conn.request("GET", "/sensors/queries/installers/ccid/v1", "", headers)
                        res = conn.getresponse()
                        if res.status == 429:
                            self._handle_rate_limit(res)
                            return self.get_ccid()
                        if res.status in [301, 302, 303, 307, 308]:
                            self._handle_redirect(res)
                            return self.get_ccid()
                        if res.status != 200:
                            raise CrowdStrikeAPIError(
                                f"Received non success response {res.status} while fetching Customer ID. Error {res.reason}"
                            )
                        data = res.read()
                        print("Successfully received Customer ID.")
                        return json.loads(data)["resources"][0]
                    def get_install_token(self):
                        """Returns the Installation Token
                        Returns:
                            token (str): Installation Token
                        Raises:
                            CrowdStrikeAPIError: If the API call fails
                        """
                        print("Requesting Installation Token from Crowdstrike backend.")
                        if self.bearer_token is None:
                            self._oauth()
                        conn = http.client.HTTPSConnection(self.cloud)
                        headers = {
                            "Authorization": f"Bearer {self.bearer_token}",
                            "User-Agent": self.user_agent,
                        }
                        conn.request(
                            "GET",
                            "/installation-tokens/queries/tokens/v1?filter=status:'valid'",
                            "",
                            headers,
                        )
                        install_token_query_resp = conn.getresponse()
                        if install_token_query_resp.status == 429:
                            self._handle_rate_limit(install_token_query_resp)
                            return self.get_install_token()
                        if install_token_query_resp.status in [301, 302, 303, 307, 308]:
                            self._handle_redirect(install_token_query_resp)
                            return self.get_install_token()
                        if install_token_query_resp.status != 200:
                            raise CrowdStrikeAPIError(
                                f"Received non success response {install_token_query_resp.status} while fetching token. Error {install_token_query_resp.reason}"
                            )
                        install_token_query_data = install_token_query_resp.read()
                        resources = json.loads(install_token_query_data)["resources"]
                        if len(resources) == 0:
                            print("No Installation token found, skipping")
                            return ""
                        install_token_id = resources[0]
                        url = f"/installation-tokens/entities/tokens/v1?ids={install_token_id}"
                        conn.request("GET", url, "", headers)
                        entities_resp = conn.getresponse()
                        if entities_resp.status == 429:
                            self._handle_rate_limit(entities_resp)
                            return self.get_install_token()
                        if entities_resp.status in [301, 302, 303, 307, 308]:
                            self._handle_redirect(install_token_query_resp)
                            return self.get_install_token()
                        if entities_resp.status != 200:
                            raise CrowdStrikeAPIError(
                                f"Received non success response {entities_resp.status} while fetching token by id {install_token_id}. Error {entities_resp.reason}"
                            )
                        entities_resp_data = entities_resp.read()
                        token = json.loads(entities_resp_data)["resources"][0]["value"]
                        print("Successfully received Installation token")
                        return token
                class SSMHelper:
                    """A helper class for SSM"""
                    def __init__(self, config):
                        self.client = boto3.client("ssm", config=config)
                    def get_parameter(self, path):
                        """Get a SSM parameter by path and return value.
                        Handles throttling exceptions by backing off and retrying.
                        Args:
                            path (str): Path to the SSM parameter
                        """
                        try:
                            response = self.client.get_parameter(
                                Name=path,
                                WithDecryption=True,
                            )
                            print(f"Successfully received SSM parameter: {path}")
                            return response["Parameter"]["Value"]
                        except botocore.exceptions.ClientError as error:
                            if (
                                error.response.get("Error", {}).get("Code", None)
                                == "ThrottlingException"
                            ):
                                wait_time = 5
                                print(f"Throttling exception, waiting {wait_time} seconds")
                                time.sleep(wait_time)
                                return self.get_parameter(path)
                            else:
                                raise error
                class SecretsManagerHelper:
                    """A helper class for Secrets Manager"""
                    def __init__(self, config):
                        self.client = boto3.client("secretsmanager", config=config)
                    def _validate_secret(self, secret_value):
                        """Validate a Secrets Manager secret contains all required fields.
                        Args:
                            secret_value (dict): Secrets Manager secret value
                        Returns:
                            valid (bool): True if secret contains all required fields
                            fields: (list): List of missing fields
                        """
                        required_fields = ["clientid", "clientsecret", "cloud"]
                        missing_fields = []
                        for field in required_fields:
                            if field not in secret_value:
                                missing_fields.append(field)
                        valid = len(missing_fields) == 0
                        return valid, missing_fields
                    def get_secret(self, secret_name):
                        """Get a Secrets Manager secret by name and return value.
                        Validates the secret contains all required fields.
                        Handles throttling exceptions by backing off and retrying.
                        Args:
                            secret_name (str): secret name of the Secrets Manager secret
                        Returns:
                            secret_value (dict): Secrets Manager secret value
                        Raises:
                            botocore.exceptions.ClientError: If the API call fails
                            ValueError: If the secret does not contain all required fields
                        """
                        try:
                            response = self.client.get_secret_value(SecretId=secret_name)
                            print(f"Successfully received Secrets Manager secret: {secret_name}")
                            secret_value = json.loads(response["SecretString"])
                            # Instead of throwing an error if the secret contains fields with
                            # mismatching casing, we convert all keys to lowercase.
                            # This eliminates this error entirely.
                            secret_value = {k.lower(): v for k, v in secret_value.items()}
                            valid, missing_fields = self._validate_secret(secret_value)
                            if not valid:
                                raise ValueError(
                                    f"Secret {secret_name} is missing required fields: {missing_fields}"
                                )
                            return secret_value
                        except botocore.exceptions.ClientError as error:
                            if (
                                error.response.get("Error", {}).get("Code", None)
                                == "ThrottlingException"
                            ):
                                wait_time = 5
                                print(f"Throttling exception, waiting {wait_time} seconds")
                                time.sleep(wait_time)
                                return self.get_secret(secret_name)
                            else:
                                raise error
                def describe_instance_information(config, instances):
                    """
                    Get SSM instance information for the provided instances
                    Args:
                        config (botocore.config.Config): Botocore configuration object
                        instances (list): List of instance IDs
                    Returns:
                        dict: SSM instance information for each instance {<instanceId>: {"InstanceStatus": <value>, ...}, ...}
                        str: Error message, if any
                    """
                    inventoryDict = {}
                    if not instances:
                        return inventoryDict, None
                    try:
                        client = boto3.client("ssm", config=config)
                        paginator = client.get_paginator("describe_instance_information")
                        page_iterator = paginator.paginate(
                            Filters=[
                                {
                                    "Key": "InstanceIds",
                                    "Values": instances,
                                }
                            ]
                        )
                        for page in page_iterator:
                            for instanceInfoList in page.get("InstanceInformationList", {}):
                                instance_id = instanceInfoList.get("InstanceId")
                                pingStatus = instanceInfoList.get("PingStatus")
                                if pingStatus == PingStatus.ONLINE:
                                    inventoryDict[instance_id] = {
                                        "InstanceStatus": InstanceStatus.ACTIVE
                                    }
                                elif pingStatus == PingStatus.CONNECTIONLOST:
                                    inventoryDict[instance_id] = {
                                        "InstanceStatus": InstanceStatus.CONNECTIONLOST
                                    }
                                elif pingStatus == PingStatus.INACTIVE:
                                    inventoryDict[instance_id] = {
                                        "InstanceStatus": InstanceStatus.CONNECTIONLOST
                                    }
                                else:
                                    inventoryDict[instance_id] = {
                                        "InstanceStatus": InstanceStatus.UNKNOWN
                                    }
                        return inventoryDict, None
                    except botocore.exceptions.ClientError as error:
                        errorMsg = f"Error calling ssm.DescribeInstanceInformation: {error}"
                        if error.response.get("Error", {}).get("Code") == "InvalidInstanceId":
                          errorMsg += f"\n\nPlease check the following instance IDs provided and verify that they are in the correct format.\n{pretty_print_instances(instances)}"
                        return inventoryDict, errorMsg
                    except Exception as error:
                        return inventoryDict, f"Error calling ssm.DescribeInstanceInformation: {error}\n\nFor instances {pretty_print_instances(instances)}"
                def get_inventory(config, instances):
                    """
                    Get SSM Inventory information for the provided instances
                    Args:
                        config (botocore.config.Config): Botocore configuration object
                        instances (list): List of instance IDs
                    Returns:
                        dict: SSM Inventory instance status for each instance {<instanceId>: {"InstanceStatus": <value>, ...}, ...}
                        str: Error message, if any
                    """
                    inventoryDict = {}
                    if not instances:
                        return inventoryDict, None
                    try:
                        client = boto3.client("ssm", config=config)
                        paginator = client.get_paginator("get_inventory")
                        page_iterator = paginator.paginate(
                            Filters=[
                                {
                                    "Key": "AWS:InstanceInformation.InstanceId",
                                    "Values": instances,
                                    "Type": "Equal",
                                }
                            ]
                        )
                        for page in page_iterator:
                            for e in page["Entities"]:
                                instance_id = e.get("Id")
                                content = (
                                    e.get("Data", {})
                                    .get("AWS:InstanceInformation", {})
                                    .get("Content", [])
                                )
                                if not content:
                                    continue
                                instanceInfo = content[0]
                                instanceInfo["Id"] = instance_id
                                inventoryDict[instance_id] = instanceInfo
                        return inventoryDict, None
                    except botocore.exceptions.ClientError as error:
                        # Handle AccessDeniedException by falling back to ssm.DescribeInstanceInformation.
                        # This ensures backwords compatbility with FalconSensor-Linux, FalconSensor-Windows, and v1/v2 of the automation document.
                        if error.response.get("Error", {}).get("Code") == "AccessDeniedException":
                            print(
                                "Unable to call ssm.GetInventory due to missing permissions. Consider adding the ssm:GetInventory action to your role. This will allow the automation document to correctly report if a instance was skipped due to being stopped, terminated, or in an unkown state."
                            )
                            return describe_instance_information(config, instances)
                        return inventoryDict, f"Error calling ssm.GetInventory: {error}\n\nFor instances {pretty_print_instances(instances)}"
                    except Exception as error:
                        return inventoryDict, f"Error calling ssm.GetInventory: {error}\n\nFor instances {pretty_print_instances(instances)}"
                def add_unknown_status(instances, inventory):
                    """
                    Adds the UNKNOWN status to instances that were not found in the inventory.
                    Args:
                        instances (list): List of instances
                        inventory (dict): Inventory of instances
                    """
                    updatedInventory = inventory.copy()
                    for instance in instances:
                        if instance not in updatedInventory:
                            updatedInventory[instance] = {"InstanceStatus": InstanceStatus.UNKNOWN}
                    return updatedInventory
                def script_handler(events, _):
                    """Handler for executeScript action
                    Args:
                        events (dict): Input for the action
                        _ (dict): Context for the action
                    Returns:
                        dict: Output for the action
                    """
                    config = Config(
                        region_name=events["region"], retries={"max_attempts": 30, "mode": "standard"}
                    )
                    response = {
                        "skipDistributor": False,
                        "failRun": False,
                        "falconOauthToken": "",
                        "message": "",
                        "errorMessage": "",
                    }
                    instances = [i for i in events["instances"] if i.strip()]
                    if len(instances) == 0:
                        response["skipDistributor"] = True
                        response["failRun"] = False
                        response["message"] = (
                            "Execution aborted: No instances were provided to the automation document."
                        )
                        return response
                    inventory, error = get_inventory(config, instances)
                    if error:
                        response["skipDistributor"] = True
                        response["failRun"] = True
                        response["errorMessage"] = error
                        return response
                    inventory = add_unknown_status(instances, inventory)
                    instanceStatusCount = {
                        InstanceStatus.ACTIVE: [],
                        InstanceStatus.CONNECTIONLOST: [],
                        InstanceStatus.STOPPED: [],
                        InstanceStatus.TERMINATED: [],
                        InstanceStatus.UNKNOWN: [],
                    }
                    for instance, v in inventory.items():
                        instanceStatusCount[v["InstanceStatus"]].append(instance)
                    print("Instances by status")
                    print(json.dumps(instanceStatusCount, indent=4))
                    response["instanceList"] = instanceStatusCount[InstanceStatus.ACTIVE]
                    if len(instanceStatusCount[InstanceStatus.ACTIVE]) == 0:
                        response["skipDistributor"] = True
                        response["failRun"] = False
                        message = "Execution aborted: No instances in the ACTIVE state."
                        response["message"] += message
                    else:
                        message = f"Targeting the following ACTIVE instances:{pretty_print_instances(instanceStatusCount[InstanceStatus.ACTIVE])}"
                        print(message)
                        response["message"] += message
                    for status, message in [
                        (
                            InstanceStatus.STOPPED,
                            f"\n\nThe following instances were skipped because they are in the STOPPED state. Start the instances and try again:{pretty_print_instances(instanceStatusCount[InstanceStatus.STOPPED])}",
                        ),
                        (
                            InstanceStatus.TERMINATED,
                            f"\n\nThe following instances were skipped because they are in the TERMINATED state:{pretty_print_instances(instanceStatusCount[InstanceStatus.TERMINATED])}",
                        ),
                        (
                            InstanceStatus.UNKNOWN,
                            f"\n\nThe following instances were skipped becuase they are in an UNKNOWN state. If the instance ID is correct and the instance is running this could indicate the instance is not managed by SSM.\nPlease refer to the following article for troubleshooting: https://repost.aws/knowledge-center/systems-manager-ec2-instance-not-appear{pretty_print_instances(instanceStatusCount[InstanceStatus.UNKNOWN])}",
                        ),
                        (
                            InstanceStatus.CONNECTIONLOST,
                            f"\n\nThe following instances were skipped becuase they are in the CONNECTIONLOST state. If the instance is running, this could indicate there is a issue between SSM and the instance.\nPlease refer to the following article for troubleshooting: https://repost.aws/knowledge-center/systems-manager-ec2-instance-not-appear{pretty_print_instances(instanceStatusCount[InstanceStatus.CONNECTIONLOST])}",
                        ),
                    ]:
                        if instanceStatusCount[status]:
                            response["message"] += message
                    if response["skipDistributor"] or instanceStatusCount[InstanceStatus.ACTIVE] == 0:
                        return response
                    if events["secretStorageMethod"] == "ParameterStore":
                        print("Using Parameter Store to retrieve secrets")
                        ssm_helper = SSMHelper(config)
                        falcon_cloud = ssm_helper.get_parameter(events["falconCloud"])
                        falcon_client_id = ssm_helper.get_parameter(events["falconClientId"])
                        falcon_client_secret = ssm_helper.get_parameter(events["falconClientSecret"])
                    else:
                        print("Using Secrets Manager to retrieve secrets")
                        secret_helper = SecretsManagerHelper(config)
                        secret_value = secret_helper.get_secret(events["secretsManagerSecretName"])
                        falcon_cloud = secret_value["cloud"]
                        falcon_client_id = secret_value["clientid"]
                        falcon_client_secret = secret_value["clientsecret"]
                    falcon_client = Falcon(falcon_cloud, falcon_client_id, falcon_client_secret)
                    response["falconCcid"] = falcon_client.get_ccid()
                    response["falconInstallToken"] = falcon_client.get_install_token()
                    response["falconOauthToken"] = falcon_client.bearer_token
                    response["falconCloud"] = falcon_client.cloud
                    return response
            outputs:
              - Name: falconCloud
                Selector: $.Payload.falconCloud
                Type: String
              - Name: falconCcid
                Selector: $.Payload.falconCcid
                Type: String
              - Name: falconInstallToken
                Selector: $.Payload.falconInstallToken
                Type: String
              - Name: falconOauthToken
                Selector: $.Payload.falconOauthToken
                Type: String
              - Name: instanceList
                Selector: $.Payload.instanceList
                Type: StringList
              - Name: skipDistributor
                Selector: $.Payload.skipDistributor
                Type: Boolean
              - Name: failRun
                Selector: $.Payload.failRun
                Type: Boolean
              - Name: errorMessage
                Selector: $.Payload.errorMessage
                Type: String
              - Name: message
                Selector: $.Payload.message
                Type: String
          - name: Branch
            action: aws:branch
            inputs:
              Choices:
                - NextStep: HandleCleanup
                  Variable: '{{ HandlePreqrequisites.skipDistributor }}'
                  BooleanEquals: true
              Default: ExecuteDistributorPackage
          - name: ExecuteDistributorPackage
            action: aws:runCommand
            nextStep: HandleCleanup
            isEnd: false
            onFailure: Continue
            inputs:
              Targets: '{{ Targets }}'
              InstanceIds: '{{ HandlePreqrequisites.instanceList }}'
              DocumentName: AWS-ConfigureAWSPackage
              Parameters:
                installationType: In-place update
                additionalArguments:
                  SSM_CS_INSTALLTOKEN: '{{HandlePreqrequisites.falconInstallToken}}'
                  SSM_CS_CCID: '{{HandlePreqrequisites.falconCcid}}'
                  SSM_CS_WINDOWS_INSTALLPARAMS: '{{WindowsInstallerParams}}'
                  SSM_CS_WINDOWS_VERSION: '{{WindowsPackageVersion}}'
                  SSM_CS_LINUX_INSTALLPARAMS: '{{LinuxInstallerParams}}'
                  SSM_CS_LINUX_VERSION: '{{LinuxPackageVersion}}'
                  SSM_CS_AUTH_TOKEN: '{{HandlePreqrequisites.falconOauthToken}}'
                  SSM_CS_HOST: '{{HandlePreqrequisites.falconCloud}}'
                name: '{{DistributorPackageName}}'
                action: '{{Action}}'
          - name: HandleCleanup
            action: aws:executeScript
            isEnd: true
            inputs:
              Runtime: python3.11
              Handler: script_handler
              InputPayload:
                region: '{{global:REGION}}'
                falconOauthToken: '{{HandlePreqrequisites.falconOauthToken}}'
                falconCloud: '{{HandlePreqrequisites.falconCloud}}'
                falconClientId: '{{FalconClientId}}'
                falconClientSecret: '{{FalconClientSecret}}'
                secretsManagerSecretName: '{{SecretsManagerSecretName}}'
                secretStorageMethod: '{{SecretStorageMethod}}'
                distributorStatus: '{{ExecuteDistributorPackage.Status}}'
                skipDistributor: '{{HandlePreqrequisites.skipDistributor}}'
                failRun: '{{HandlePreqrequisites.failRun}}'
                errorMessage: '{{HandlePreqrequisites.errorMessage}}'
                message: '{{HandlePreqrequisites.message}}'
              Script: |-
                """Module for handling cleanup for CrowdStrike Falcon AWS Automation document"""
                import http.client
                import urllib.parse
                import time
                from datetime import datetime
                import json
                import base64
                import boto3
                from botocore.config import Config
                import botocore.exceptions
                class CrowdStrikeAPIError(Exception):
                    """Crowdstrike API error"""
                class Falcon:
                    """Crowdstrike Falcon API class"""
                    def __init__(self, cloud, client_id, client_secret, bearer_token=None):
                        """Default constructor
                        Args:
                            cloud (str): Falcon API Gateway
                            client_id (str): Falcon OAuth2 Client ID
                            client_secret (str): Falcon OAuth2 Client Secret
                            bearer_token (str, optional): CrowdStrike API OAUTH2 Token. Defaults to None.
                        """
                        self.cloud = cloud.replace("https://", "").replace("http://", "")
                        self.client_id = client_id
                        self.client_secret = client_secret
                        self.user_agent = "crowdstrike-custom-api-automation-doc/v2.0.0"
                        self.bearer_token = bearer_token
                    def _handle_redirect(self, res):
                        """Updates the cloud attribute with the new location received in the redirect
                        Args:
                            res (HTTPResponse): HTTP response object
                        Raises:
                            CrowdStrikeAPIError: If we are unable to handle the redirect
                        """
                        location = res.getheader("Location")
                        if location is None:
                            raise CrowdStrikeAPIError(
                                f"Received redirect to {res.getheader('X-Cs-Region')}, but no location header was found. Ensure you are using the correct API Gateway."
                            )
                        new_cloud = urllib.parse.urlparse(location).netloc
                        print(
                            f"WARNING: While using {self.cloud}, received redirect to {new_cloud}. Please update the value used for the crowdstrike cloud to prevent future redirects."
                        )
                        self.cloud = new_cloud
                    def _handle_rate_limit(self, res):
                        """Handles rate limit exceptions by sleeping 10 seconds or X-RateLimit-RetryAfter
                        whichever is largest
                        Args:
                            res (HTTPResponse): HTTP response object
                        """
                        retry_after = int(res.getheader("X-RateLimit-RetryAfter"))
                        retry_datetime = datetime.utcfromtimestamp(retry_after)
                        now = datetime.utcnow()
                        wait_duration = max((retry_datetime - now).total_seconds(), 10)
                        print(f"Rate limit exceeded. Retrying after {wait_duration} seconds.")
                        time.sleep(wait_duration)
                    def revoke_oauth_token(self):
                        """Revokes a OAuth bearer token
                        Raises:
                            CrowdStrikeAPIError: If the API call fails
                        """
                        print("Revoking Authentication token")
                        credentials = base64.b64encode(
                            f"{self.client_id}:{self.client_secret}".encode()
                        ).decode()
                        params = urllib.parse.urlencode(
                            {
                                "client_id": self.client_id,
                                "token": self.bearer_token,
                            }
                        )
                        headers = {
                            "Content-Type": "application/x-www-form-urlencoded",
                            "Authorization": f"Basic {credentials}",
                            "User-Agent": self.user_agent,
                        }
                        conn = http.client.HTTPSConnection(self.cloud)
                        conn.request("POST", "/oauth2/revoke", params, headers)
                        res = conn.getresponse()
                        if res.status == 429:
                            self._handle_rate_limit(res)
                            return self.revoke_oauth_token()
                        if res.status in [301, 302, 303, 307, 308]:
                            self._handle_redirect(res)
                            return self.revoke_oauth_token()
                        if res.status != 200:
                            print(
                                f"Received non success response {res.status} while revoking token. Error {res.reason}"
                            )
                            return
                        print("Successfully revoked Authentication token")
                class SSMHelper:
                    """A helper class for SSM"""
                    def __init__(self, config):
                        self.client = boto3.client("ssm", config=config)
                    def get_parameter(self, path):
                        """Get a SSM parameter by path and return value.
                        Handles throttling exceptions by backing off and retrying.
                        Args:
                            path (str): Path to the SSM parameter
                        """
                        try:
                            response = self.client.get_parameter(
                                Name=path,
                                WithDecryption=True,
                            )
                            print(f"Successfully received SSM parameter: {path}")
                            return response["Parameter"]["Value"]
                        except botocore.exceptions.ClientError as error:
                            if (
                                error.response.get("Error", {}).get("Code", None)
                                == "ThrottlingException"
                            ):
                                wait_time = 5
                                print(f"Throttling exception, waiting {wait_time} seconds")
                                time.sleep(wait_time)
                                return self.get_parameter(path)
                            else:
                                raise error
                class SecretsManagerHelper:
                    """A helper class for Secrets Manager"""
                    def __init__(self, config):
                        self.client = boto3.client("secretsmanager", config=config)
                    def _validate_secret(self, secret_value):
                        """Validate a Secrets Manager secret contains all required fields.
                        Args:
                            secret_value (dict): Secrets Manager secret value
                        Returns:
                            valid (bool): True if secret contains all required fields
                            fields: (list): List of missing fields
                        """
                        required_fields = ["clientid", "clientsecret", "cloud"]
                        missing_fields = []
                        for field in required_fields:
                            if field not in secret_value:
                                missing_fields.append(field)
                        valid = len(missing_fields) == 0
                        return valid, missing_fields
                    def get_secret(self, secret_name):
                        """Get a Secrets Manager secret by name and return value.
                        Validates the secret contains all required fields.
                        Handles throttling exceptions by backing off and retrying.
                        Args:
                            secret_name (str): secret name of the Secrets Manager secret
                        Returns:
                            secret_value (dict): Secrets Manager secret value
                        Raises:
                            botocore.exceptions.ClientError: If the API call fails
                            ValueError: If the secret does not contain all required fields
                        """
                        try:
                            response = self.client.get_secret_value(SecretId=secret_name)
                            print(f"Successfully received Secrets Manager secret: {secret_name}")
                            secret_value = json.loads(response["SecretString"])
                            # Instead of throwing an error if the secret contains fields with
                            # mismatching casing, we convert all keys to lowercase.
                            # This eliminates this error entirely.
                            secret_value = {k.lower(): v for k, v in secret_value.items()}
                            valid, missing_fields = self._validate_secret(secret_value)
                            if not valid:
                                raise ValueError(
                                    f"Secret {secret_name} is missing required fields: {missing_fields}"
                                )
                            return secret_value
                        except botocore.exceptions.ClientError as error:
                            if (
                                error.response.get("Error", {}).get("Code", None)
                                == "ThrottlingException"
                            ):
                                wait_time = 5
                                print(f"Throttling exception, waiting {wait_time} seconds")
                                time.sleep(wait_time)
                                return self.get_secret(secret_name)
                            else:
                                raise error
                def script_handler(events, _):
                    """Handler for executeScript action
                    Args:
                        events (dict): Input for the action
                        _ (dict): Context for the action
                    Returns:
                        dict: Output for the action
                    """
                    if (
                        events["falconOauthToken"]
                        and "falconOauthToken" not in events["falconOauthToken"]
                    ):
                        config = Config(
                            region_name=events["region"],
                            retries={"max_attempts": 30, "mode": "standard"},
                        )
                        if events["secretStorageMethod"] == "ParameterStore":
                            print("Using Parameter Store to retrieve secrets")
                            ssm_helper = SSMHelper(config=config)
                            falcon_cloud = events["falconCloud"]
                            falcon_client_id = ssm_helper.get_parameter(events["falconClientId"])
                            falcon_client_secret = ssm_helper.get_parameter(
                                events["falconClientSecret"]
                            )
                        else:
                            print("Using Secrets Manager to retrieve secrets")
                            secret_helper = SecretsManagerHelper(config=config)
                            secret_value = secret_helper.get_secret(events["secretsManagerSecretName"])
                            falcon_cloud = events["falconCloud"]
                            falcon_client_id = secret_value["clientid"]
                            falcon_client_secret = secret_value["clientsecret"]
                        falcon_client = Falcon(
                            falcon_cloud,
                            falcon_client_id,
                            falcon_client_secret,
                            events["falconOauthToken"],
                        )
                        falcon_client.revoke_oauth_token()
                    if events["message"] and "message" not in events["message"]:
                        print(events["message"])
                    if events["errorMessage"] and "errorMessage" not in events["errorMessage"]:
                        print(events["errorMessage"])
                    if events["failRun"]:
                        raise Exception(
                            "Marking the run as failed. Check the automation document output and the HandlePreqrequisites step logs for more details."
                        )
                    distributor_status = events["distributorStatus"]
                    possible_states = [
                        "success",
                        "pending",
                        "inprogress",
                        "failed",
                        "waiting",
                        "timedout",
                        "cancelled",
                        "cancelling",
                    ]
                    valid_states = ["success", "pending"]
                    failed_run = False
                    failed_steps = []
                    if distributor_status.lower() in possible_states:
                        if distributor_status.lower() not in valid_states:
                            failed_steps.append("ExecuteDistributorPackage")
                            failed_run = True
                    if failed_run:
                        raise Exception(
                            f"Failed to execute distributor package. Failed steps: {failed_steps} check the step's logs for more details"
                        )
        outputs:
          - HandlePreqrequisites.message
          - HandlePreqrequisites.errorMessage
  CrowdStrikeSSMAssociation:
    Type: AWS::SSM::Association
    Properties:
      AssociationName: crowdstrike-falcon-sensor-deploy
      Name: !Ref CrowdStrikeAutomationDocument
      AutomationTargetParameterName: InstanceIds
      Targets:
        - Key: InstanceIds
          Values: ['*']
      Parameters:
        AutomationAssumeRole:
          - !Sub "arn:${AWS::Partition}:iam::${AWS::AccountId}:role/${AutomationAssumeRoleName}"
        Action: [!Ref Action]
        SecretStorageMethod: [SecretsManager]
        SecretsManagerSecretName: [!Ref SecretsManagerSecretName]
        LinuxInstallerParams: [!Ref LinuxInstallerParams]
        WindowsInstallerParams: [!Ref WindowsInstallerParams]
        LinuxPackageVersion: [!Ref LinuxPackageVersion]
        WindowsPackageVersion: [!Ref WindowsPackageVersion]
      MaxConcurrency:
        Fn::If: [SetMaxConcurrency, !Ref MaxConcurrency, !Ref AWS::NoValue]
      MaxErrors:
        Fn::If: [SetMaxErrors, !Ref MaxErrors, !Ref AWS::NoValue]
      ComplianceSeverity: !Ref ComplianceSeverity
      ScheduleExpression: !Ref ScheduleExpression
